<style>
	.center {
		margin-right: auto;
		margin-left: auto;
	}

	.center-text {
		text-align: center ! important;
	}

	.example-table {
		margin-top: 10px;
		text-align: left;
		width: 100%;
	}

	.example-table td {
		max-width: 0;
		word-wrap: break-word;
		vertical-align: top; 
	}

	.example-table .vertical-spacer {
		height: 5px;
	}

	.inline {
		display: inline;
	}

	.section {
		margin-top: 19px;
		margin-bottom:19px;
	}

	.section:first-child, .section:first-child > h3:first-child {
		margin-top: 0;
	}

	.paragraph {
		margin-top: 10px;
		margin-bottom: 10px;
		text-align: left;
	}

	.paragraph ul, .paragraph pre {
		margin-top: 3px;
		margin-bottom: 3px;
	}

	ul.padded > li, ol.padded > li {
		margin-bottom: 13px;
	}
	ul.padded > li:last-child, ol.padded > li:last-child {
		margin-bottom: 0;
	}

	pre {
		tab-size: 4;
	}

	.billboard {
		line-height: 1em;
		outline: solid 1px black;
	}
</style>

<div>
	<div class="section">
		<h3>Description</h3>
		<div class="paragraph">
			What if arithmetic operator precedence were reversed? Could you handle it?
		</div>
		<div class="paragraph">
			Expressions within parentheses is still evaluated first, but + and - precede * and /.
			<br>
			Like with traditional arithmetic, "ties" (e.g. + and -) are evaluated in the order they appear.
		</div>
	</div>

	<div class="section">
		<h3>Input</h3>
		<div class="paragraph">
			A valid arithmetic expression, using positive decimal integers, parentheses, and the operators +, -, and *.
			<br>
			Intermediate values are guaranteed never to exceed +- 1,000,000,000.
		</div>
	</div>

	<div class="section">
		<h3>Output</h3>
		<div class="paragraph">
			The value of the expression.
		</div>
	</div>

	<table class="section example-table">
		<tr>
			<th>Input</th>
			<th>Input</th>
		</tr>
		<tr>
			<td>
<pre>2 * 1 + 1</pre>
			</td>
			<td>
<pre>(20) * (2 + 1) + 1</pre>
			</td>
		</tr>
		<tr>
			<th>Output</th>
			<th>Output</th>
		</tr>
		<tr>
			<td>
<pre>4</pre>
			</td>
			<td>
<pre>80</pre>
			</td>
		</tr>
	</table>
</div>

Use stacks.